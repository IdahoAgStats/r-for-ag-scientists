---
title: "Lesson 10: Aggregating & Summarising Data"
---

::: {.callout-caution collapse="false"}
## Learning Goals

At the end of this lesson, you should:

* be able to aggregate data and perform actions on those aggregated data using `group_by()` + `summarise()`
:::

You may find yourself wanting to calculate summary statistics across a grouping variable. To do this, a data set needs to be split up by that variable, a summary statistic calculated, and the resulting data recombined, or 'split-apply-combine'. There's some nice tools to do this in the **dplyr** package. 

### Prep Work

First, load libraries & import data: 


```{r, eval=FALSE}
library(dplyr)

variety_trials <- read.csv(here::here("outputs", "trial_data_cleaned.csv")) %>% 
  mutate(year = as.character(year))
#trial_metadata <- readr::read_csv(here::here("data", "trial_metadata.csv"))
```

```{r, echo=FALSE, include=FALSE}
library(dplyr)

#trial_metadata <- readr::read_csv(here::here("data", "trial_metadata.csv"))

variety_trials <- read.csv(here::here("data", "trial_data.csv")) %>% 
  mutate(trial = gsub("_H_", "_H-", trial)) %>% 
  tidyr::separate(trial, c("program", "crop", "location", "year"),
                  sep = "_", remove = FALSE)
```

### Basic grouping & aggregation

The `group_by` will group data and then any statistic can be calculated or summary action can be done on that grouped data using `summarise()`.

The basic formula: 
```{r, eval=FALSE}
mydata %>% group_by(variable) %>% summarise(new_var = ...)
```


This data set can several categorical variables we can group on: 

```{r}
str(variety_trials)
```

```{r}
variety_trials %>% group_by(trial) %>% tally()
```

Let's group by crop and pull out the mean yield and standard deviation. 

```{r}
yield_crop <- variety_trials %>% group_by(crop) %>% 
  summarise(yield_mean = mean(yield, na.rm = TRUE), 
            yield_sd = sd(yield, na.rm = TRUE),
            yield_min = min(yield, na.rm = TRUE),
            yield_max = max(yield, na.rm = TRUE),
            total = n())

yield_crop
```

::: callout-note

`summarise()` only returns a single value back for each group. If you want more than that (e.g. to run a linear model on each group), there are other tools for that. This is intended to be addressed in Lesson 16.

:::

### Grouping across multiple variables

Let's examine how many crops and years there are: 
```{r}
table(variety_trials$crop, variety_trials$year)
```

This tells us how many rows of data occur for each variable combination. 

You can group by as many conditions as you want: 
```{r}
variety_trials %>% group_by(crop, year) %>% 
  summarise(protein_na = sum(is.na(grain_protein))) %>% arrange(desc(protein_na))
```

::: {.callout-warning}
## FYI

You can group by a numeric variable. ***dplyr*** will look for common values to group observations. This can be successful when there are repeat 'integers' (e.g. year), but if all values are unique (often the case with floating point numbers), then the number of groups is the number of observations. 

:::

### Summarising across multiple variables

Use `across()` to conduct the same summary action(s) across multiple columns. 

```{r}
variety_trials %>% group_by(trial) %>% 
  summarise(across(c(yield, grain_protein), ~ mean(.x, na.rm = T)))
```

### Row-wise summaries

Many operations in R are already vectorized across rows, but when they are not, you can use `rowwise()` to implement that. 

Field disease scoring may benefit from this system. Often, several measaurements are made on a single experimental unit (usually a plot), and those measurements are averaged together to create a final disease incidence score. Here is how to do that with `rowwise()`. 

First, simulate a set of disease scores between 0 and 100 (indicating percent infection). 

```{r}
score_range <- c(0:10 * 10L)
scores <- sample(score_range, 50, replace = TRUE)

disease_df <- data.frame(plot = 1:10,
                         score1 = scores[1:10],
                         score2 = scores[11:20],
                         scores3 = scores[21:30],
                         scores4 = scores[31:40],
                         scores5 = scores[41:50])
disease_df
```

```{r}
disease_df_sum <- disease_df %>% rowwise()
  mutate(score_final = mean(score1:score5),
        max_score = max(score1:score5))
diseease_df_sum
```

::: callout-tip
## Putting it all together

The function `across()` also works with `mutate()` statements if you want to mutate several columns at once (for example, rounding numbers in multiple columns). 

:::
