---
title: "Solutions to Practice G"
---

(@) Count missing data in "weather.csv". This one is a bit hard! 

First, import the data: 

```{r}
weather <- read.csv(here::here("data", "weather_data.csv")) 
```

Next, we need to test if a value is missing or not with `is.na()`. As a logical his will return a `TRUE` or `FALSE`. Those end up being equivalent to '1' (TRUE) and '0' (FALSE), as you may recall from data type coercion. You can check with by running `as.integer(c(TRUE, TRUE, FALSE, TRUE))` which should return `1 1 0 1`. Once that is done, the observations can be grouped by 'station' and the columsn can be summed under the assumption that all the missing values are represented by a "1" to indicate it is missing. 
```{r}
library(dplyr)

weather %>%
  mutate(across(c(tavg, tmax, tmin), ~ is.na(.x))) %>% 
  group_by(station) %>%
  summarise(across(c(tavg, tmax, tmin), ~ sum(.x)))
```
::: {.callout-note}
## Programming Tip

This exercise is pretty hard! It took me several tries to get it right. If you have trouble, take the exercise one step at a time, troubleshooting each step separately. It's helpful to write down - with a pen and paper - what it is you want to do and how you think you might do this.

In this case, we wanted to count the number of missing data for three data columns for each station. My first (failed approach) was to group by station and the use a summary command to (1) test if the observations are missing and (2) count those missing data. Well, it turned out the observations can be converted from a value to a logical in a `summarise()` call (since this is actually a mutation action not a summary). So, instead, the solution is to (1) change the values to a logical indicating if each is missing or not, (2) group by station, and (3) count all the missing data for the requested data columns. Once I came to that realization, I could then focus on making the code correct so it would run without errors. 

Writing down the exact problem you want to solve and *how* you want to solve it (the steps you want to take) can help you focus on what code is required to complete those steps. New programmers often merge the steps of how to fix a problem along with the effort required to write and troubleshoot code, which can quickly lead to distraction and feeling overwhelmed. One thing at a time, my peeps! 

:::

(@) Calculate average temperatures minimum and maximum

```{r}
weather %>% group_by(station) %>%
    summarise(max_temp = mean(tmax, na.rm = TRUE),
              min_temp = mean(tmin, na.rm = TRUE))
```

(@) Find the largest and smallest differences between the daily minimum and maximum temperatures for each year. 

```{r}
weather %>% 
    filter(!is.na(tmin) & !is.na(tmax)) %>%   # filter out missing data
    mutate(temp_diff = abs(tmax - tmin)) %>% # make the calculation for all 
    group_by(year) %>% # grouping step
    summarise(max_diff = max(temp_diff), # extract the maximum
              min_diff = min(temp_diff)) # extract the minimum
```

The function `abs()` was used to find the absolute difference. If both daily temperatures were negative, then the overall difference was negative, which ended up being the 'minimum', although by minimum difference, I was actually thinking about what was closest to zero. When there were wide swings in daily temperature, how big were they? And conversely, how small could these daily swings be? 

