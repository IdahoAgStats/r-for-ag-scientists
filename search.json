[
  {
    "objectID": "practice/solution02.html",
    "href": "practice/solution02.html",
    "title": "Solutions to Practice #2",
    "section": "",
    "text": "If you convert it using as.integer, it will look rather funky:\n\nmyvar <- factor(c(2010:2022))\nas.integer(myvar)\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13\n\n\nIt must first be converted to a character to preserve the information in the levels and then an integer\n\nas.integer(as.character(myvar))\n\n [1] 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019 2020 2021 2022"
  },
  {
    "objectID": "practice/solution04.html",
    "href": "practice/solution04.html",
    "title": "Solutions to Practice #4",
    "section": "",
    "text": "….Is there anything to write?"
  },
  {
    "objectID": "practice/practice04.html",
    "href": "practice/practice04.html",
    "title": "Practice #4",
    "section": "",
    "text": "(for data import lesson)\n\nImport one of your data sets using two of the functions taught:\n\n(save your data in different format to enable this)\n\nread.csv()\nread_csv()\nread_excel()\nread.delim()\n\n\nExamine the data using the tools you have learned thus far. Did everything import as expected? Are your variables coded as they should be? Are numeric variables numeric? Are missing data detected as thus?"
  },
  {
    "objectID": "practice/solution01.html",
    "href": "practice/solution01.html",
    "title": "Solutions to Practice #1",
    "section": "",
    "text": "\\[ \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}\\]\n\\(\\pi\\) = 3.14 \\(e\\) = 2.718 \\(\\mu\\) = 50 \\(\\sigma\\) = 5 \\(x\\) = 20\n\nFor this problem, there are several possible solutions:\n\n\nManual the whole way down:\n\n\n1/(5*(2*3.14)^0.5)*2.718^(-0.5*((20-50)/5)^2)\n\n[1] 1.217755e-09\n\n\n\nEmploying a few shortcuts\n\n\n1/(5*sqrt(2*pi))*exp(-0.5*((20-50)/5)^2)\n\n[1] 1.215177e-09\n\n\n\nR function that estimates the standard normal density (the equation above is the probability density function for the normal distribution)\n\n\ndnorm(x = 20, mean = 50, sd = 5)\n\n[1] 1.215177e-09\n\n\n\n\n\n\n\n\nNote\n\n\n\nIt’s not expected you would be aware of the second and third solutions given what has been taught thus far, but it’s helpful to be aware that many shortcuts exist in R to make coding easier.\n\n\n\nUsing the manual approach:\n\n\nx = c(10, 20, 30, 40, 50)\n1/(5*(2*3.14)^0.5)*2.718^(-0.5*((x-50)/5)^2)\n\n[1] 1.014069e-15 1.217755e-09 2.679505e-05 1.080317e-02 7.980869e-02"
  },
  {
    "objectID": "practice/practice01.html",
    "href": "practice/practice01.html",
    "title": "Practice #1",
    "section": "",
    "text": "Make this calculation using R math operators\n\n\\[ \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{1}{2}(\\frac{x-\\mu}{\\sigma})^2}\\] \\(\\pi\\) = 3.14 \\(e\\) = 2.718 \\(\\mu\\) = 50 \\(\\sigma\\) = 5 \\(x\\) = 20\n\nRepeat this calculation except for \\(x\\) = {10, 20, 30, 40, 50, 60}"
  },
  {
    "objectID": "practice/practice03.html",
    "href": "practice/practice03.html",
    "title": "Practice #3",
    "section": "",
    "text": "(for lessons on data structures)\n\nYou have this object in your R session: x = 7. What is the difference between x[1] and x?\nYou have this list: mylist = list(x1 = \"snow\", x2 = 45:65, x3 = rep(letters[1:3], each = 3), x4 = matrix(1:100, nrow = 10)). Return this list without x3.\nYou have this data frame:\n\n\ndf <- data.frame(one = 1:10,\n                 two = rnorm(10))\ndf$three <- df$two + rnorm(10)\ndf$four <- sample(c(\"A\", \"B\"), 10, replace = TRUE)\n\n\nAdd another column, ‘five’, that is a character variable consisting of levels that are fruits of your choice.\nAdd another column, ‘six’ that is actually ‘five’ coerced into a factor\nMake a new data frame with the columns in this order: five, one, four, two, three\n\n\nYou have this object in R session: m100 = matrix(1:100, ncol = 20, nrow = 5). What do you do if you want all the rows from this matrix, but only values 1:50?\nWhat happens if you don’t have enough values to make a completed filled matrix (e.g. you have 99 observations rather than 100)?"
  },
  {
    "objectID": "practice/solution03.html",
    "href": "practice/solution03.html",
    "title": "Solutions to Practice #3",
    "section": "",
    "text": "There is no difference.\nHere is the list\n\n\nmylist = list(x1 = \"snow\", x2 = 45:65, x3 = rep(letters[1:3], each = 3), x4 = matrix(1:100, nrow = 10))\nmylist\n\n$x1\n[1] \"snow\"\n\n$x2\n [1] 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65\n\n$x3\n[1] \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"c\" \"c\" \"c\"\n\n$x4\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    1   11   21   31   41   51   61   71   81    91\n [2,]    2   12   22   32   42   52   62   72   82    92\n [3,]    3   13   23   33   43   53   63   73   83    93\n [4,]    4   14   24   34   44   54   64   74   84    94\n [5,]    5   15   25   35   45   55   65   75   85    95\n [6,]    6   16   26   36   46   56   66   76   86    96\n [7,]    7   17   27   37   47   57   67   77   87    97\n [8,]    8   18   28   38   48   58   68   78   88    98\n [9,]    9   19   29   39   49   59   69   79   89    99\n[10,]   10   20   30   40   50   60   70   80   90   100\n\n\nThere are two ways to remove x3. The First is to create a new list from the object ‘mylist’ and don’t include x3:\n\nmylist2 <- list(mylist[[1]], mylist[[2]], mylist[[4]])\nmylist2\n\n[[1]]\n[1] \"snow\"\n\n[[2]]\n [1] 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65\n\n[[3]]\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    1   11   21   31   41   51   61   71   81    91\n [2,]    2   12   22   32   42   52   62   72   82    92\n [3,]    3   13   23   33   43   53   63   73   83    93\n [4,]    4   14   24   34   44   54   64   74   84    94\n [5,]    5   15   25   35   45   55   65   75   85    95\n [6,]    6   16   26   36   46   56   66   76   86    96\n [7,]    7   17   27   37   47   57   67   77   87    97\n [8,]    8   18   28   38   48   58   68   78   88    98\n [9,]    9   19   29   39   49   59   69   79   89    99\n[10,]   10   20   30   40   50   60   70   80   90   100\n\n\nLists also let you declare a list item as NULL which makes it completely go away!\n\nmylist[[3]] <- NULL\nmylist\n\n$x1\n[1] \"snow\"\n\n$x2\n [1] 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65\n\n$x4\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,]    1   11   21   31   41   51   61   71   81    91\n [2,]    2   12   22   32   42   52   62   72   82    92\n [3,]    3   13   23   33   43   53   63   73   83    93\n [4,]    4   14   24   34   44   54   64   74   84    94\n [5,]    5   15   25   35   45   55   65   75   85    95\n [6,]    6   16   26   36   46   56   66   76   86    96\n [7,]    7   17   27   37   47   57   67   77   87    97\n [8,]    8   18   28   38   48   58   68   78   88    98\n [9,]    9   19   29   39   49   59   69   79   89    99\n[10,]   10   20   30   40   50   60   70   80   90   100\n\n\n\nHere is the data frame:\n\n\ndf <- data.frame(one = 1:10,\n                 two = rnorm(10))\ndf$three <- df$two + rnorm(10)\ndf$four <- sample(c(\"A\", \"B\"), 10, replace = TRUE)\n\n\ndf$five <- sample(c(\"apple\", \"huckleberry\"), 10, replace = TRUE)\ndf$six <- as.factor(df$five)\n\n\nnew_df <- df[,c(5, 1, 4, 2, 3)]\nnew_df\n\n          five one four          two      three\n1        apple   1    A -1.030023564 -0.6241419\n2        apple   2    B -0.568546307 -0.5618738\n3        apple   3    A  0.004675472  0.2934242\n4        apple   4    A -1.091349951 -0.1507307\n5  huckleberry   5    B -0.648295564  1.2188196\n6        apple   6    B -0.871690105 -0.4394988\n7  huckleberry   7    B -0.623400715 -1.7739292\n8  huckleberry   8    B  0.077988853  1.4455625\n9        apple   9    B -1.389419526 -1.7625070\n10 huckleberry  10    A -0.629254956 -0.2700568\n\n\n\nHere is the matrix:\n\n\nm100 = matrix(1:100, ncol = 05, nrow = 20)\nm100\n\n      [,1] [,2] [,3] [,4] [,5]\n [1,]    1   21   41   61   81\n [2,]    2   22   42   62   82\n [3,]    3   23   43   63   83\n [4,]    4   24   44   64   84\n [5,]    5   25   45   65   85\n [6,]    6   26   46   66   86\n [7,]    7   27   47   67   87\n [8,]    8   28   48   68   88\n [9,]    9   29   49   69   89\n[10,]   10   30   50   70   90\n[11,]   11   31   51   71   91\n[12,]   12   32   52   72   92\n[13,]   13   33   53   73   93\n[14,]   14   34   54   74   94\n[15,]   15   35   55   75   95\n[16,]   16   36   56   76   96\n[17,]   17   37   57   77   97\n[18,]   18   38   58   78   98\n[19,]   19   39   59   79   99\n[20,]   20   40   60   80  100\n\n\nSolution #1 if you want to maintain the original size of the matrix:\n\nm100_1 <- m100\nm100_1[,4:5] <- NA\nm100_1[11:20,3] <- NA\nm100_1\n\n      [,1] [,2] [,3] [,4] [,5]\n [1,]    1   21   41   NA   NA\n [2,]    2   22   42   NA   NA\n [3,]    3   23   43   NA   NA\n [4,]    4   24   44   NA   NA\n [5,]    5   25   45   NA   NA\n [6,]    6   26   46   NA   NA\n [7,]    7   27   47   NA   NA\n [8,]    8   28   48   NA   NA\n [9,]    9   29   49   NA   NA\n[10,]   10   30   50   NA   NA\n[11,]   11   31   NA   NA   NA\n[12,]   12   32   NA   NA   NA\n[13,]   13   33   NA   NA   NA\n[14,]   14   34   NA   NA   NA\n[15,]   15   35   NA   NA   NA\n[16,]   16   36   NA   NA   NA\n[17,]   17   37   NA   NA   NA\n[18,]   18   38   NA   NA   NA\n[19,]   19   39   NA   NA   NA\n[20,]   20   40   NA   NA   NA\n\n\nSolution #2 if you want remove columns from the matrix that are composed only of missing data.\n\nm100_2 <- m100[, 1:3]\nm100_2[11:20, 3] <- NA\nm100_2\n\n      [,1] [,2] [,3]\n [1,]    1   21   41\n [2,]    2   22   42\n [3,]    3   23   43\n [4,]    4   24   44\n [5,]    5   25   45\n [6,]    6   26   46\n [7,]    7   27   47\n [8,]    8   28   48\n [9,]    9   29   49\n[10,]   10   30   50\n[11,]   11   31   NA\n[12,]   12   32   NA\n[13,]   13   33   NA\n[14,]   14   34   NA\n[15,]   15   35   NA\n[16,]   16   36   NA\n[17,]   17   37   NA\n[18,]   18   38   NA\n[19,]   19   39   NA\n[20,]   20   40   NA\n\n\n\nThe values are recycled, starting at the beginning of the specificed data:\n\n\nmatrix(1:9, ncol = 5, nrow = 2, byrow = TRUE)\n\nWarning in matrix(1:9, ncol = 5, nrow = 2, byrow = TRUE): data length [9] is not\na sub-multiple or multiple of the number of rows [2]\n\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9    1\n\n\nIf you don’t want that to happen, pad your input data with NA:\n\nmatrix(c(1:9, NA), ncol = 5, byrow = TRUE)\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    2    3    4    5\n[2,]    6    7    8    9   NA\n\n\nMeta-lesson: always always always check your object to make sure it looks like what you expected it to\nCommon checks:\n\nthe dimensions (row number, column number, length, etc) are what you expect\nthe data types are what you expect\nthe values are what you expect"
  },
  {
    "objectID": "practice/practice02.html",
    "href": "practice/practice02.html",
    "title": "Practice #2",
    "section": "",
    "text": "This was a year variable that we once wanted defined as a factor, but no longer. Convert this back to an integer and make sure the output is what you expect.\n\n\nmyvar <- factor(c(2010:2022))"
  },
  {
    "objectID": "CoC.html",
    "href": "CoC.html",
    "title": "Code of Conduct",
    "section": "",
    "text": "University of Idaho Carpentries is dedicated to providing a harassment-free experience for participants of the conference regardless of age, gender, sexual orientation, disability, physical appearance, race, or religion (or lack thereof).\nWe encourage the open exchange of ideas and expression and thus require an environment that recognizes the inherent worth of every person and group. An inclusive space free of harassment encourages interaction among diverse groups. We want to make certain our workshops and courses are welcoming, and encourages participants to be involved moving forward.\nAll participants (including organizers, attendees, instructors and volunteers) at UI Carpentries Workshops are required to agree to the following code of conduct. Reports of violation to this Code of Conduct should be addressed to the course/workshop lead instructor.\nThis Code of Conduct (CoC) applies to any participant in a University of Idaho Carpentries Workshop. Note that this code augments rather than replaces legal rights and obligations pertaining to any particular situation.\n\nExpected Behavior\nAll workshop/course participants are expected to behave in accordance with professional standards, with both this Code of Conduct as well as their respective employer’s policies governing appropriate workplace behavior, and all applicable laws.\nWe’re committed to providing welcome environments where people behave according to professional standards. We expect everyone at any UI Carpentries-affiliated event to contribute to a welcoming, civil, safe, and tolerant environment.\nExamples of encouraged behavior that contributes to a positive environment include:\n\nUsing welcoming and inclusive language\nBeing respectful of differing viewpoints and experiences\nGracefully accepting constructive criticism\nFocusing on what is best for everyone at the event\nShowing empathy towards other participants\n\n\n\nUnacceptable Behavior\nHarassment will not be tolerated in any form, including but not limited to:\n\nIntimidation or harassment of any kind.\nOffensive comments related to gender, gender identity and expression, sexual orientation, disability, physical appearance, body size, race, age, religion or any other status protected by laws in which the conference or program is being held.\nUnwelcome comments regarding a person’s lifestyle choices and practices, including those related to food, health, parenting, drugs, and employment.\nDeliberate misgendering, “outing,” or use of “dead” or rejected names.\nGratuitous or off-topic blatant sexual images or behavior in spaces where they are not appropriate.\nNot respecting the privacy of other participants\n\n\n\nHarassment in online channels\nSome of our workshops are online event. Please use these guidelines when engaging with participants. The above Code of Conduct applies to an online event, with the addition of:\n\nAvoid using overtly sexual or offensive usernames or profile photos which might detract from a friendly, safe and welcoming environment for all.\nDo not publish text/screenshots of anything shared in private communication channels without explicit consent from the author. This includes screenshots of private messages to public channels, as well as conversations on public channels to anywhere outside of UI Carpentries Workshop.\nDo not direct message someone without their permission.\nDo not record sessions without the presenter’s permission.\nThe meeting host/organizer should be aware of privacy concerns for different tools. For tips on security, a good place to start is: Securing Your Zoom Meetings.\n\nThis CoC applies to all University of Idaho Carpentries online spaces.\n\n\nResponses to Code of Conduct Violations\nWe will follow all University of Idaho and Idaho State requirements regarding how to handle incidents of harassment.\n\n\nWhat To Do If You Witness or Are Subject To Unacceptable Behavior\nIf you are being harassed, notice that someone else is being harassed, or have any other concerns relating to harassment, please contact the lead instructor immediately.\n\n\nAcknowledgements\nThis CoC is adapted from RConsortium CoC and the Carpentries CoC This policy is licensed under a Creative Commons Attribution 4.0 International license."
  },
  {
    "objectID": "lessons/final_Lesson.html",
    "href": "lessons/final_Lesson.html",
    "title": "Moving on",
    "section": "",
    "text": "If you made this far, congratulations! Learning any programming language takes a big effort.\nThis is only the beginning. You will probably need more R knowledge, both generalized and specialized, to accomplish your research goals. Here are a few resources to develope general data science skills in R.\n\nData Science in a Box is a online course by Mine Çetinkaya-Rundel with videos for further development of R skills.\nR 4 Data Science by Hadley Wickham and Garret Grolemund is a comprehensive book providing guidance on leveraging R for data science aims\nWhat They Forgot to Teach you about R (and workshop version) describes some meta processes for ensuring a repeatable workflow.\n\nThere are many other resources to help develop skills in genetics, bioinformatics, geospatial analysis, Bayesian statistics, ….you name it. Look for the resources that will help you develop skills in R. One very reliable place to start are CRAN Task Views which provide a list of packages and other relevant R resources specific for a given topic such as environmetrics (ecology), spatial tools and agriculture.\nAnother good source for keeping up with major developments in R, contributed R packages and other R resources is R Weekly which puts out a weekly blog post (also available in a weekly podcast and an RSS feed)."
  },
  {
    "objectID": "lessons/Lesson02.html",
    "href": "lessons/Lesson02.html",
    "title": "Lesson 2: Introduction to RStudio",
    "section": "",
    "text": "Learning Recap\n\n\n\n\n\nAt the end of this lesson, you should understand:\n\nWhat the different tabs in each of the panes of RStudio do\nWhat is in each menu item in Rstudio and have a general sense of functionality available\nRStudio is more than a graphical user interface for R. It is an integrated development environment (IDE), that is a full service application for supporting software development. It can perform multitudes, so more than most people need. It is the supermarket of R functionality. Like a supermarket, there are parts of RStudio you will visit frequently and parts you will rarely if ever use. After 10+ years of using RStudio on a near daily basis, there are several parts of it that I continue to be unfamiliar with! Ths is okay - clearly, I have not needed those parts. You will come to find what sections youn will need most over time and practice.\nStill, it helps to have a guided tour. Let’s dive into this."
  },
  {
    "objectID": "lessons/Lesson02.html#the-panes",
    "href": "lessons/Lesson02.html#the-panes",
    "title": "Lesson 2: Introduction to RStudio",
    "section": "The Panes",
    "text": "The Panes\n\nThe Console/Terminal/Background Jobs\n\n\n\n\n\nDefault location: left or bottom left\n\n\n\n\n\n\n\nTab\nFunction\n\n\n\n\nConsole\nwhere R commands are actually done\n\n\nTerminal\nuse a terminal language such as bash or the windows command prompt\n\n\nBackground jobs\nusual pacakage installation\n\n\nRender\nfor building markdown or quarto documents (only present when actively rendering)\n\n\n\nIn this workshop, we will only be using the Console.\n\n\nFiles/Plots/Packages/Help/Viewer/Presentation\n\n\n\n\n\nDefault location: bottom right\nProbably the most useful pane - we will be here frequently!\n\n\n\nTab\nFunction\n\n\n\n\nPlots\nview plots\n\n\nFiles\nexplore your file system\n\n\nPackages\ninstall, update and load packages\n\n\nHelp\nhelps files & examples\n\n\nViewer\nfor previewing websites\n\n\nPresentation\nfor previewing presentations\n\n\n\nWe will not be using the Viewer or Presentations tabs in this workshop.\nWhat are Packages?\nThese make the world go around in R. All of R consists of packages or libraries that have certain functionality associated with them. Some of are maintained by the R core team, others are maintained by outsiders. All packages are open source and most are a volunteer effort. When you open R, several packages are loaded automatically: base, datasets, graphics, grDevices, methods, stats, utils.\nWe will talk about package installation and usage later in this course/workshop.\n\n\nEnvironment/History/Connections/Build/Git/Tutorial\n\n\n\n\n\n\n\n\n\n\n\n\nTab\nFunction\n\n\n\n\nEnvironment\nobjects created and existing in your current R session\n\n\nHistory\nprevious R command run\n\n\nConnections\nto connect to an external database\n\n\nBuild\nfor building R packages and other large projects\n\n\nGit\nonly visible if you’ve initialized a git repository\n\n\nTutorial\ntutorials build by Posit (very helpful)\n\n\n\nhere\n\n\nOur Scripts Pane\n\n\n\n\n\ndefault location: upper left\nThese are all the files we create and edit: .R, .Rmd, .txt, …\nwhen we open files from the “Files” pane, this is where it shows up"
  },
  {
    "objectID": "lessons/Lesson02.html#the-upper-menu-items",
    "href": "lessons/Lesson02.html#the-upper-menu-items",
    "title": "Lesson 2: Introduction to RStudio",
    "section": "The Upper Menu Items",
    "text": "The Upper Menu Items\n\n\n\n\n\n\nFile\n\nopening and/or creating files\n\nopening and/or creating projects\n\nrecent files, recent project\n\n(standard file functionality)\n\n\n\nEdit\n\ncopy, paste, find\nvery handy “find in files” feature!\n\n\n\nCode\n\nincredible useful set of commands\nsome are very simple (e.g. “comment lines”), others are complex (e.g. “rename in scope”)\nover time, you will learn what these mean and perhaps make use of them (if you don’t, that is okay)\n\n\n\nView\n\nrearrange panes\nzoom in/out\noverall not that useful, except for the shortcuts\n\n\n\nPlots\n\nmeh\n\n\n\nSession\n\nvery handy for restarting your R session\nmanually set the working directory (we will do this in a few weeks)\n\n\n\nBuild\n\nadvanced tools for building packages, websites, et cetera. I’ve never visited this part of the supermarket.\n\n\n\nDebug\n\ntools for debugging code (removing scripting errors). We will not use this in the workshop! But you can learn more about it here.\n\n\n\nProfile\n\nfor code profiling (checking how long it takes your code to run). We will also not be using this in the workshop. This is part of the supermarket I rarely visit.\n\n\n\nTools\n\nsome handy utility function. I mostly use this menu item to set preferences via “Global Options”.\n\n\n\nHelp\n\nmore utility functions. You can check for RStudio updates here, access community help forum, and other forms of documentation in addition to standard help files.\n\n\n\nmore\nRstudio has a massive number of keyboard shortcuts. You can find them in the menu (Help –> Cheat Sheets) and summarized in this cheat sheet"
  },
  {
    "objectID": "lessons/Lesson14.html",
    "href": "lessons/Lesson14.html",
    "title": "Lesson 14: Publication-Quality Plots with ggplot2",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\n\n\n\n\n\n\n\n\nPutting it all together"
  },
  {
    "objectID": "lessons/Lesson05.html",
    "href": "lessons/Lesson05.html",
    "title": "Lesson 5: Data Structures",
    "section": "",
    "text": "The longest and most important lesson of them all! These are the foundation of everything you are likely to do R as a scientists. Understanding these will take time and practice, so you may find yourself returning to this page to remind yourself of these data structures."
  },
  {
    "objectID": "lessons/Lesson05.html#introduction-to-common-data-structures",
    "href": "lessons/Lesson05.html#introduction-to-common-data-structures",
    "title": "Lesson 5: Data Structures",
    "section": "Introduction to Common Data Structures",
    "text": "Introduction to Common Data Structures\nPreviously, we looked at data types. Now we need to consider how those types are arranged into complex structures (that is, objects) we can access and manipulate.\nThere are several data structures commonly used in R:\n\nvector\ndata.frame\nmatrix\nlist\n\n\nThe vector\nA collection of items all coerced to be the same data type that we learned about in the previous lesson. These are sometimes called “atomic vectors” in the R documentation.\n\nv1 <- 1:10\nv2 <- c(\"apples\", \"pears\", \"oranges\")\nv3 <- c(1, 5, 7, 85)\n\nA vector can also consist of only one value or no value.\n\nv4 <- \"violets\"\nv5 <- TRUE\nv6 <- NA\nv7 <- NULL\n\nIt has the attribute length and each item in a vector can also be named.\n\nlength(v1); length(v2); length(v3)\n\n[1] 10\n\n\n[1] 3\n\n\n[1] 4\n\n\n\nnames(v3) <- c(\"A\", \"B\", \"C\", \"D\")\nv3\n\n A  B  C  D \n 1  5  7 85 \n\n\n\nAccessing items\nItems in a vector can be accessed by referencing the numeric position in the vector, starting at 1 and ending at the vector length. If a vector has length of one, it not necessary to index that.\nx[1] will access the first item in the vector, while x[5] will access the 5th element. Multiple item can be indexed: x[c(1,5)]. If an index position, it repeated, that item will be returned as often as it is called:\n\nv1[1]\n\n[1] 1\n\nv1[5]\n\n[1] 5\n\nv1[c(1,5)]\n\n[1] 1 5\n\nv1[c(1,1)]\n\n[1] 1 1\n\n\nAny collection of numbers can be used to index items in a vector:\n\nv1[c(1, 1:5)]\n\n[1] 1 1 2 3 4 5\n\n\nWhat happens if a negative number is used?\n\nv1[-1]\n\n[1]  2  3  4  5  6  7  8  9 10\n\n\n\nEverything but that index position is returned.*\n\nWhat if you index a position that does not exist?\n\nv1[0]\n\ninteger(0)\n\nv1[20]\n\n[1] NA\n\n\nItems in a vector can also be accessed by their name:\n\nv3[\"A\"]\n\nA \n1 \n\n\nWhat happens if there are replicate names in a vector and you try to index (extract a value) for that name?\n\nnames(v3) <- c(\"A\", \"B\", \"C\", \"A\")\nv3\n\n A  B  C  A \n 1  5  7 85 \n\nv3[\"A\"]\n\nA \n1 \n\n\n\nAnswer (Only the first instance of a name is returned)*\n\n\n\n\nThe data frame\nA collection of vectors all of the name length. Each vector is a single data type, but different columns can be different data types. This is similar to a typical workbook you might open in Excel or another spreadsheet program. These can be only one column wide, but they often consist of more than that.\n\nd1 <- data.frame(var1 = 1:5,\n                 var2 = c(\"a\", \"b\", \"a\", \"b\", \"c\"),\n                 var3 = \"alpha\")\nd1\n\n  var1 var2  var3\n1    1    a alpha\n2    2    b alpha\n3    3    a alpha\n4    4    b alpha\n5    5    c alpha\n\n\nNotes that is a single value is supplied for a column, it will be repeated for the entire column.\nA data frame has attributes for:\n\nnrow number of rows\nncol number of columns\ncolnames column names\nrownames row names (if none are provided, R will generate integer row names starting at 1)\n\n\n\n\n\n\n\nNote\n\n\n\nWhile duplicate column names in a data frame are allowed, they are not advised, and will throw an error during data import.\n\n\n\nnrow(d1)\n\n[1] 5\n\nncol(d1); length(d1)\n\n[1] 3\n\n\n[1] 3\n\ndim(d1) # tells us rows and columns in one command!\n\n[1] 5 3\n\n\n\nrownames(d1)\n\n[1] \"1\" \"2\" \"3\" \"4\" \"5\"\n\ncolnames(d1)\n\n[1] \"var1\" \"var2\" \"var3\"\n\n\nWhat does length(d1) return? How about names(d1)?\nWe can look at the overall structure of a data.frame with str():\n\nstr(d1)\n\n'data.frame':   5 obs. of  3 variables:\n $ var1: int  1 2 3 4 5\n $ var2: chr  \"a\" \"b\" \"a\" \"b\" ...\n $ var3: chr  \"alpha\" \"alpha\" \"alpha\" \"alpha\" ...\n\n\n——> This is the data structure most commonly used in R <——\n\nAccessing items\nLike vectors, data frames can be indexed by position, except now we have two dimensions to consider. You can extract individual elements in a data frame by references the row and column position, `my_dataframe[row, column].\nExtract the item located in row 1, column 2:\n\nd1[1,2]\n\n[1] \"a\"\n\n\nExtract the entire first row:\n\nd1[1, ]\n\n  var1 var2  var3\n1    1    a alpha\n\n\nWhen the column position is left empty, all columns are returned.\nExtract the entire first column:\n\nd1[ ,1]\n\n[1] 1 2 3 4 5\n\n\nWhen the row position is left empty, all rows are returned.\nExtract the values located in the first 2 rows and first two columns:\n\nd1[1:2, 1:2]\n\n  var1 var2\n1    1    a\n2    2    b\n\n\nReturn everything except the third columns\n\nd1[ ,-3]\n\n  var1 var2\n1    1    a\n2    2    b\n3    3    a\n4    4    b\n5    5    c\n\n\nReturn everything except the first 2 rows:\n\nd1[-(1:2),  ]\n\n  var1 var2  var3\n3    3    a alpha\n4    4    b alpha\n5    5    c alpha\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen indexing positions in a vector or data frame (or anything else), the amount of whitespace does not affect the outcome. These are equivalent: d[1,2], d[1, 2], d[ 1, 2]\n\n\n\n\nColumn Referencing\nData in R data frames can also be referred to by their column names using the notation dataframe$column_name:\n\nd1$var1\n\n[1] 1 2 3 4 5\n\n\nThe data are returned as a vector (with the typical attributes of a vector: length and names).\nAnother alternative (less commonly used in the wild) is this notation: dataframe[[\"column_name\"]]\n\nd1[[\"var1\"]]\n\n[1] 1 2 3 4 5\n\n\n\n\n\nThe matrix\nLike a data.frame: it is a collection of vectors all the same length, except all vector must be the same data type.\n\nm1 <- as.matrix(d1)\nm1\n\n     var1 var2 var3   \n[1,] \"1\"  \"a\"  \"alpha\"\n[2,] \"2\"  \"b\"  \"alpha\"\n[3,] \"3\"  \"a\"  \"alpha\"\n[4,] \"4\"  \"b\"  \"alpha\"\n[5,] \"5\"  \"c\"  \"alpha\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nAn R matrix is not strictly to the mathematical concept of a matrix, but if you make an R matrix consisting only of numbers, it can be used like a mathematical matrix. Furthermore, there several mathematical operations that are intended to only work on matrices such as matrix multiplication (e.g. %*%, upper.tri(), diag()).\n\n\nA matrix can be created by providing a vector of numbers and telling it to populate a table of given dimensions:\n\nx = 1:100\nm2 <- matrix(data = x, nrow = 5, ncol = 20, byrow = TRUE)\nm2\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n[1,]    1    2    3    4    5    6    7    8    9    10    11    12    13    14\n[2,]   21   22   23   24   25   26   27   28   29    30    31    32    33    34\n[3,]   41   42   43   44   45   46   47   48   49    50    51    52    53    54\n[4,]   61   62   63   64   65   66   67   68   69    70    71    72    73    74\n[5,]   81   82   83   84   85   86   87   88   89    90    91    92    93    94\n     [,15] [,16] [,17] [,18] [,19] [,20]\n[1,]    15    16    17    18    19    20\n[2,]    35    36    37    38    39    40\n[3,]    55    56    57    58    59    60\n[4,]    75    76    77    78    79    80\n[5,]    95    96    97    98    99   100\n\n\nSince the row and column names were no set when making the matrix, default names are giving indicating the numeric position. An R matrix can take row and column names attributes, but those are optional (and as we will soon, useless for indexing).\nPractice: try out the previous command, except changing the byrow argument to FALSE.\n\ncolnames(m1)\n\n[1] \"var1\" \"var2\" \"var3\"\n\nrownames(m1)\n\nNULL\n\n\n\nAccessing items\nMatrices can be indexed in the same fashion as data frames using this notation matrix[row, column]. The matrix we created earlier conveniently already has default row and column names telling us their numeric position:\n\nm2\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n[1,]    1    2    3    4    5    6    7    8    9    10    11    12    13    14\n[2,]   21   22   23   24   25   26   27   28   29    30    31    32    33    34\n[3,]   41   42   43   44   45   46   47   48   49    50    51    52    53    54\n[4,]   61   62   63   64   65   66   67   68   69    70    71    72    73    74\n[5,]   81   82   83   84   85   86   87   88   89    90    91    92    93    94\n     [,15] [,16] [,17] [,18] [,19] [,20]\n[1,]    15    16    17    18    19    20\n[2,]    35    36    37    38    39    40\n[3,]    55    56    57    58    59    60\n[4,]    75    76    77    78    79    80\n[5,]    95    96    97    98    99   100\n\n\nSo, to pull out the columns for numbers divisible by 5, we can reference every 5th column:\n\nm2[ , c(5, 10, 15, 20)]\n\n     [,1] [,2] [,3] [,4]\n[1,]    5   10   15   20\n[2,]   25   30   35   40\n[3,]   45   50   55   60\n[4,]   65   70   75   80\n[5,]   85   90   95  100\n\n\n\nmatrix(1:99, nrow = 5, ncol = 20)\n\nWarning in matrix(1:99, nrow = 5, ncol = 20): data length [99] is not a sub-\nmultiple or multiple of the number of rows [5]\n\n\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n[1,]    1    6   11   16   21   26   31   36   41    46    51    56    61    66\n[2,]    2    7   12   17   22   27   32   37   42    47    52    57    62    67\n[3,]    3    8   13   18   23   28   33   38   43    48    53    58    63    68\n[4,]    4    9   14   19   24   29   34   39   44    49    54    59    64    69\n[5,]    5   10   15   20   25   30   35   40   45    50    55    60    65    70\n     [,15] [,16] [,17] [,18] [,19] [,20]\n[1,]    71    76    81    86    91    96\n[2,]    72    77    82    87    92    97\n[3,]    73    78    83    88    93    98\n[4,]    74    79    84    89    94    99\n[5,]    75    80    85    90    95     1\n\n\nMatrices cannot be indexed by their name like in data frames; matrix$name will return an error.\n\ncolnames(m2) <- LETTERS[1:20]\nm2\n\n      A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S   T\n[1,]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19  20\n[2,] 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  40\n[3,] 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59  60\n[4,] 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  80\n[5,] 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100\n\n\n\nm2$A\n\nError in m2$A: $ operator is invalid for atomic vectors\n\n\nUnder the hood, a matrix is basically a vector that is being forced into rectangular dimensions.\n\n\n\nThe list\nThis is the wildest and least structured data structure that exists. A list is like a closet that happens to be filled with other objects. A vector, scalar and data frame can all be combined into a list. A list can contain other lists inside of it (although this list nesting can be cumbersome to deal with).\n\nL1 <- list(v1, v2, v3, d1, m1)\nstr(L1)\n\nList of 5\n $ : int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ : chr [1:3] \"apples\" \"pears\" \"oranges\"\n $ : Named num [1:4] 1 5 7 85\n  ..- attr(*, \"names\")= chr [1:4] \"A\" \"B\" \"C\" \"A\"\n $ :'data.frame':   5 obs. of  3 variables:\n  ..$ var1: int [1:5] 1 2 3 4 5\n  ..$ var2: chr [1:5] \"a\" \"b\" \"a\" \"b\" ...\n  ..$ var3: chr [1:5] \"alpha\" \"alpha\" \"alpha\" \"alpha\" ...\n $ : chr [1:5, 1:3] \"1\" \"2\" \"3\" \"4\" ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:3] \"var1\" \"var2\" \"var3\"\n\n\nEach list item can have a name. Or not.\n\nL1 <- list(\"number\" = v1, \"flower\" = v3, v4, \"df\" = d1, m1)\nnames(L1)\n\n[1] \"number\" \"flower\" \"\"       \"df\"     \"\"      \n\nstr(L1)\n\nList of 5\n $ number: int [1:10] 1 2 3 4 5 6 7 8 9 10\n $ flower: Named num [1:4] 1 5 7 85\n  ..- attr(*, \"names\")= chr [1:4] \"A\" \"B\" \"C\" \"A\"\n $       : chr \"violets\"\n $ df    :'data.frame': 5 obs. of  3 variables:\n  ..$ var1: int [1:5] 1 2 3 4 5\n  ..$ var2: chr [1:5] \"a\" \"b\" \"a\" \"b\" ...\n  ..$ var3: chr [1:5] \"alpha\" \"alpha\" \"alpha\" \"alpha\" ...\n $       : chr [1:5, 1:3] \"1\" \"2\" \"3\" \"4\" ...\n  ..- attr(*, \"dimnames\")=List of 2\n  .. ..$ : NULL\n  .. ..$ : chr [1:3] \"var1\" \"var2\" \"var3\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nIf you end up with too many objects, you can always delete them with the rm() function:\nrm(myvar)\nrm(var1, var2, var3)\nIf one object ends up with the wrong name, you can copy the object to a new name and delete the old version:\nnew <- old\nrm(old)\n\n\n\nAccessing items\nAs mentioned earlier, lists are relatively unstructured and follow fewer rules. You can access list items by their numeric position, list[[1]], or their name (if it exsits), list$name.\n\nL1[[1]]\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nL1$df\n\n  var1 var2  var3\n1    1    a alpha\n2    2    b alpha\n3    3    a alpha\n4    4    b alpha\n5    5    c alpha\n\n\nOnce a list item is accessed, the normal indexing rules apply. The 4th item in the list called “L1” is a data frame.\n\nL1[[4]]\n\n  var1 var2  var3\n1    1    a alpha\n2    2    b alpha\n3    3    a alpha\n4    4    b alpha\n5    5    c alpha\n\nL1[[4]]$var1\n\n[1] 1 2 3 4 5\n\nL1[[4]][1:2,]\n\n  var1 var2  var3\n1    1    a alpha\n2    2    b alpha"
  },
  {
    "objectID": "lessons/Lesson05.html#checking-the-class-of-a-data-structure",
    "href": "lessons/Lesson05.html#checking-the-class-of-a-data-structure",
    "title": "Lesson 5: Data Structures",
    "section": "Checking the class of a data structure",
    "text": "Checking the class of a data structure\nUse the class() command.\n\nclass(d1)\n\n[1] \"data.frame\"\n\nclass(m2)\n\n[1] \"matrix\" \"array\" \n\nclass(L1)\n\n[1] \"list\"\n\n\nYou can also explicity ask if it is one class or another:\n\nis.data.frame(d1)\n\n[1] TRUE\n\nis.list(L1)\n\n[1] TRUE\n\nis.matrix(m2)\n\n[1] TRUE\n\nis.data.frame(m2)\n\n[1] FALSE\n\nis.list(d1)\n\n[1] TRUE\n\n\nA data frame is also list. You can think of each row being a list containing potentially different data types."
  },
  {
    "objectID": "lessons/Lesson05.html#final-notes",
    "href": "lessons/Lesson05.html#final-notes",
    "title": "Lesson 5: Data Structures",
    "section": "Final Notes",
    "text": "Final Notes\nThere are actually several more object types, but these are by far the ones you are most likely to encounter and use.\n\nMore resources:\n\nFor a deeper look into vectors, read this chapter from R 4 Data Science\nTo learn more about subsetting, read this chapter from Advanced R (warning: it is advanced!)\n\nFor a very comprehensive guide to R object types, check out the official R language manual. Warning: this manual is extremely technical. If you choose to check it out, be patient with yourself. It may take several readings to fully understand the content.\n\n\n\n\n\n\nPutting it all together\n\n\n\nWhen information is extracted from a vector, data.frame, matrix or list using these tools, the returned information can always be assigned to a new object:\n\nnew <- d1[1:2, -3]\n\nSometimes, we need that information assigned to a new object so we can it use later. Other times, printing the extracted information to the console is sufficient for meeting researcher needs.\nWe can also use indexing to assign new information. What if we wanted to assign an NA to position instead of its current value?\n\nnew[2,2] <- NA"
  },
  {
    "objectID": "lessons/Lesson01.html",
    "href": "lessons/Lesson01.html",
    "title": "Lesson 1: Math Operators",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\nUnderstand sorts of math operators available in R and how to use them\nUnderstand logical operators in R\nBe aware of the order of operations\nBe aware of how whitespace is interpreted in R\nUnderstand how to use parentheses, brackets, braces and quotations in R\n\n\n\n\n\nUse R as a calculator:\nAddition, substraction, multiplication, division\n\n1 + 3\n\n[1] 4\n\n10 - 15\n\n[1] -5\n\n2*8\n\n[1] 16\n\n60/12\n\n[1] 5\n\n\nexponentiate\n\n3^2\n\n[1] 9\n\n2^4\n\n[1] 16\n\n9^0\n\n[1] 1\n\n2^-2\n\n[1] 0.25\n\n\nroots (square, cube, ….)\n\n4^(1/2)\n\n[1] 2\n\n8^(1/3)\n\n[1] 2\n\n\nlogs\n\nlog(10)\n\n[1] 2.302585\n\n\n(base e)\nlog with base 10\n\nlog10(10)\n\n[1] 1\n\n\nUsing sign:\n\n3*-4\n\n[1] -12\n\n\nLike in standard math, only negatively signed numbers need to be specified.\nThere’s more:\ninteger division (the remainder is discarded)\n\n5 %/% 3\n\n[1] 1\n\n\nmodulus operator (return the remainder after division)\n\n5 %% 3\n\n[1] 2\n\n\n….and so much more\nLogical Operators\nThese test for conditions and return either a TRUE or FALSE\n\n\n\nsyntax\nFunction\n\n\n\n\n==\nequal\n\n\n!=\ndoes not equal\n\n\n<\nless than\n\n\n>\ngreater than\n\n\n<=, >=\nless than and equal to, and greater than equivalent\n\n\n\n\n1 == 1\n\n[1] TRUE\n\n1 == 2\n\n[1] FALSE\n\n1 != 2\n\n[1] TRUE\n\n1 < 1\n\n[1] FALSE\n\n1 > 1\n\n[1] FALSE\n\n1 <= 1\n\n[1] TRUE\n\n1 >= 1\n\n[1] TRUE\n\n\nUse & if two things must be true and | if one of two things must be true:\n\n1 < 2 & 1 != 1\n\n[1] FALSE\n\n1 < 2 | 1 != 1\n\n[1] TRUE\n\n\n\n\nOrder of operations.\nWhat results from this?\n\n2*6 - 6*9 + 3*30 /7\n\nThe rules:\n\noperations go left to right\nexponents are first, followed by ‘unary operators’ (that is, variable signs)\nmultiplication and division before subtraction and/or addition\nlogical operators come after all mathematical transformations\nParentheses overall all other rules!\n\nHere is the official R guide to order of operations (warning: this is complicated and refers to functions beyond mathematical operations).\n\n\nSome notes on R syntax\n\nmost often, the amount of white space does not matter.\nThese are the same:\n\n\n4/3\n\n[1] 1.333333\n\n4/    3\n\n[1] 1.333333\n\n4    /  3\n\n[1] 1.333333\n\n\n\nthese are also the same\n\n\nlog(10)\n\n[1] 2.302585\n\nlog( 10 )\n\n[1] 2.302585\n\nlog ( 10)\n\n[1] 2.302585\n\n\n\na hard return between lines of code is enough to separate the commands\nexception: unclosed parentheses, brackets, or quotes. R will wait for these to be completed. A single quote must always be complemented by a second single quote, and a double quote likewise must always have a second quote to complete it. Left parentheses, curly braces, or brackets much also be accompanying by their right-sided complement.\ngood examples\n\n{ }\n( )\n[ ]\n\"  \"\n' '\n` `\n\nbad examples\n\n'\n(  } ] \n\"\n' \"\n\nthere is no difference between double and single quotes on a practical level, but R will interpret them as different commands (so a single quote cannot close a double quote). This is useful when there is nested levels of quoting (rare), and yet, it happens now and then.\n\n\n\n\n\n\n\nPutting it all together\n\n\n\nCheck the “History” tab in the upper right hand pane (this should be to the right of the “Environment” tab). What is there?\nIf you followed along and coded the above examples, you should see the command you ran previously (including any mistakes). This is your command history. There are several icons directly above your history - explore what those do (hoover before clicking any icon to make sure you are okay with action before performing it)."
  },
  {
    "objectID": "lessons/Lesson09.html",
    "href": "lessons/Lesson09.html",
    "title": "Lesson 9: Reshaping Data Sets",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\nbe able to convert long data set to wide and the reverse"
  },
  {
    "objectID": "lessons/Lesson09.html#final-notes",
    "href": "lessons/Lesson09.html#final-notes",
    "title": "Lesson 9: Reshaping Data Sets",
    "section": "Final Notes",
    "text": "Final Notes\nThis is the end of lessons on data wrangling. There is additional functionality that we have touched on that you may find useful to know.\nR 4 Data Science by Hadley Wickam and Garret Grolemund\n\n\n\n\n\n\nPutting it all together"
  },
  {
    "objectID": "lessons/Lesson13.html",
    "href": "lessons/Lesson13.html",
    "title": "Lesson 13: Exploratory Plotting in R",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\n\n\n\n\n\n\n\n\nPutting it all together"
  },
  {
    "objectID": "lessons/Lesson04.html",
    "href": "lessons/Lesson04.html",
    "title": "Lesson 4: Introduction to R data types",
    "section": "",
    "text": "::: {.callout-caution, collapse=false} ## Learning Goals\nAt the end of this lesson, you should:\n:::\nR is a programming language and like all programming languages, it has special conventions for defining how information is classified on your computer and what types of actions can be performed on different object types. This is related to your computer hardware, how computer memory is allocated for R processes nd so forth. You don’t need to understand the guts of this to use R. (But should you ever want to learn, this is fascinating material).\nThe most common object types and the rules that govern them are described in this lesson."
  },
  {
    "objectID": "lessons/Lesson04.html#data-types",
    "href": "lessons/Lesson04.html#data-types",
    "title": "Lesson 4: Introduction to R data types",
    "section": "Data types",
    "text": "Data types\n\nNumeric\nPreviously, we created an object in R that was a collection or sequence of numbers.\n\nx1 <- 1:10\n\nThese numbers are technically integers. We can also create “floating point numbers” (e.g. with precision past the decimal point):\n\nx2 <- c(1.25, 2.718, 10.000)\n\n\n\nCharacter\nThese can also be created for character variables:\n\nx3 <- \"apple\"\nx4 <- c(\"orange\", \"banana\")\n\nCheck the type for each R object\n\ntypeof(x1)\n\n[1] \"integer\"\n\ntypeof(x2)\n\n[1] \"double\"\n\ntypeof(x3)\n\n[1] \"character\"\n\ntypeof(x4)\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can force a number to be a integer by adding an L to a number as long as it does not contain a decimal pont (e.g. c(0L, 1L, 2L))\n\n\nThere are two other special classes:\n\n\nLogical\n\nconsisting of TRUE and FALSE values\n\n\nx5 <- c(TRUE, FALSE, FALSE, TRUE)\ntypeof(x5)\n\n[1] \"logical\"\n\n\n\n\nFactor\n\nx6 <- factor(c(\"one\", \"two\", \"three\"))\ntypeof(x6)\n\n[1] \"integer\"\n\nx6\n\n[1] one   two   three\nLevels: one three two\n\n\nFactors often look like character objects, except there exists several pre-defined levels which exist regardless if they are found in the object.\n\nx7 <- factor(c(\"one\", \"two\", \"three\"), \n             levels = c(\"one\", \"two\", \"three\", \"four\"))\nx7\n\n[1] one   two   three\nLevels: one two three four\n\n\nFactors are complicated and take some time to fully understand. At this time, we are going to put the topic of factors aside and focus on other more immediately relevant topics."
  },
  {
    "objectID": "lessons/Lesson04.html#object-type-coercion",
    "href": "lessons/Lesson04.html#object-type-coercion",
    "title": "Lesson 4: Introduction to R data types",
    "section": "Object type coercion",
    "text": "Object type coercion\n\nR will automatically an assign an object type based on the items present within object. It will try to assign the simplest type possible. Here are the types from simplest to most complex:\n\n\\[logical < integer < numeric < character\\]\n(Factors are not listed because they are technically integers. Factors are weird!)\nWhat classes do you think results from each of these?\n\nx8 <- c(8, 9.2)\nx9 <- c(0, 0, 0, 0)\nx10 <- c(TRUE, FALSE, 1L, 0L)\nx11 <- c(1, 2, \"pear\", -6:2, TRUE)\n\nObjects can be coerced with these functions:\n\nas.character(x8)\nas.factor(x10)\nas.logical(x10)\nas.numeric(x11)\n\n\n\n\n\n\n\nPutting it all together\n\n\n\nLook at the object created in the lesson in the Global Environment pane. For each object, the object class and the first few values will be listed."
  },
  {
    "objectID": "lessons/Lesson03.html",
    "href": "lessons/Lesson03.html",
    "title": "Lesson 3: Vectorizing Operations",
    "section": "",
    "text": "Vectorizing operations\nUsing R as a calculator between a few numbers is handy, but typically we are hoping to do so much more with it, such as performing a calculations across a long list of numbers.\nR is naturally vectorized, which means that you can easily perform a mathematical operation across a vector of numbers (no need to write loops!)\nSay we have a collection of numbers from 10 to 20 and we want to multiple them all by 12. We can create a sequence of numbers by wrapping them all in c() command (for “concatenate”) and separating each with a comma.\n\nc(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)\n\n [1] 10 11 12 13 14 15 16 17 18 19 20\n\n\nThen those numbers can be operated on by any math operator:\n\nc(10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20) * 10 - 1\n\n [1]  99 109 119 129 139 149 159 169 179 189 199\n\n\nThere’s also a quicker way to specify a sequence of integers using the notation start:end:\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nIt also counts down:\n\n20:10\n\n [1] 20 19 18 17 16 15 14 13 12 11 10\n\n\nAnd works with negative integers:\n\n-5:5\n\n [1] -5 -4 -3 -2 -1  0  1  2  3  4  5\n\n\nThese can be operated on:\n\n(-5:5)^2\n\n [1] 25 16  9  4  1  0  1  4  9 16 25\n\n\n\n\nObject assignment\nIt is rather cumbersome to continually retype numbers, even while using a shortcut. There’s a general rule of “DRY” when coding, which means “Don’t repeat yourself”. We can avoid this by assigning these numbers to an R object.\nTraditionally, the left arrow is used for object assignment, <- (less than symbol + a dash), but the standard equals sign, = also works. These are equivalent:\n\nx <- 1\nx = 1\n\nWe can assign multiple numbers to an object\n\nx_vector <- 1:10\ny_vector <- c(2, 4, 6, 8, 10)\n\nThe left arrow assignment <- takes everything on the right side of the arrow and assigns it the object name on the left.\nWhat’s going with object names?\nIt is your choice (mostly) about what to name R objects. There are a few rules to follow:\n\nspaces are generally not allowed and a huge pain - avoid at all costs!\nDon’t start with a number or symbol! (this is technically possible, but a huge pain)\nchoose a name that is short, yet descriptive\nR is case sensitive, so test is different from Test and TEST. Be mindful of this! It trips many folks up.\n\nIt’s possible that you will thank yourself for using lowercase and avoiding special symbols (aside from . and _)\nif you start a function name with a “.” (e.g. .variable), you won’t see it listed in the global environment (which can be frustrating)\nyou cannot use “reserved words” from the R language (terms set aside for very specific purposes in R). When typing these in an R console, they usually light up in a special colors.\n\n\n.z <- 1:10\n\nHere is some discussion on object naming in R.\n|————-|—————-| |reserved word | meaning | | TRUE FALSE | logical | | NA | missing value | | NaN | not a number/undefined | | NULL | no value/undefined | | Inf, -Inf | infinity | | for in | for loops | | if else while break next repeat | control flow | | NA_integer_ NA_real_ NA_complex_ NA_character_ | missing data by class\nIt’s easy to forgot these. Run ?reserved in an R console to remind yourself if need be.\nSome examples of reserved words in the wild:\n\nlog(0)\n\n[1] -Inf\n\n0/0\n\n[1] NaN\n\n2/0\n\n[1] Inf\n\n\n\n\n\n\n\n\nPutting it all together\n\n\n\nCheck the environment pane. These are the object you created during the session. This is where you will see all objects created, unless you have choosen to render the objects invisible by starting their object names with a ., a period.\n\n\n\n\n\n\n\n\nLearning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\nunderstand how to assign variables and collections of numbers to an object name\nknown the rules for how to name objects\nunderstand reserved words in R and how to find them\nbe able to create a sequence of numbers in R using any starting value and any ending value"
  },
  {
    "objectID": "lessons/Lesson06.html",
    "href": "lessons/Lesson06.html",
    "title": "Special Lesson 6: R Functions & R Help",
    "section": "",
    "text": "The Mechanics of R Functions\nWe have thus far used a few R functions without explicitly stating how to call them properly.\nThe majority of functions in R follow this format:\n\nfunction_name(arg1, arg2, arg3)\n\nWhere “arg” refers to a function argument (that is, a piece of information the function can use).\nA function has a name, and can take several arguments within the parentheses. These argument values can be provided by providing each argument in the expected order:\n\nfunction_name(value1, value2, value3)\n\nNote that each positional argument is not being explicitly referenced. However, we can specify each argument when calling a function:\n\nfunction_name(arg1 = value1, arg2 = value21, arg3 = value3)\n\nWhen specifying the argument explicitly, we don’t have to follow the order of arguments:\n\nfunction_name(arg1 = value1, arg3 = value3, arg2 = value3)\n\nThis approach of using named arguments is very helpful when there is a very long list of potential argument and you only plan to specify a small portion of them.\nWe can also combined positional argument and named arguments:\n\nfunction_name(value1, arg3 = value3)\n\nIn this case, arg2 has been completed ommitted. When an argument is not specified, that implies the default arguments for that function will be used instead. In order to find out the default argument values for a function, we need to consult the R help files.\n\n\nUsing R Help\nYou can search for a function directly using the search windows in the upper right of the “Help” pane.\nYou can also search using this notation: ?function_name.\nLet’s check out the help file for sample(), a function designed to randomly sample items and return that random sample to us.\n\n?sample\n\nHere is a screenshot of the window that hopefully popped up in your RStudio help pane:\n\nknitr::include_graphics(here::here(\"images\", \"help_sample_ex.png\"))\n\n\n\n\nAll help files follow this format\n\nDescription what the function does\nUsage how the function is called; this is where default argument may be listed\nArgument the named arguments available in the function (often the most useful part of the help file)\nDetails an optional section providing various computational details\nValue what is returned after the function is run\nReferences any technical, scientific or peer-reviewed lit references supporting the computational procedures implemented in the function\nSee Also similar functions (usually not very useful)\nExamples actual examples of the function in the wild! These are hit-or-miss on their overall utility, but when I’m desperate to understand how to properly call a function, this has helped me.\n\nAt the very bottom is the package the function came from and a link to an index of all functions associated with that package. This can come in handy when you want to browse all functions available in a package.\nLooking at the sample() help file, here is what is it telling us:\n\nThe first argument is a vector of choices for the function to sample randomly\nThe next argument is the number to sample. By default, it will return a sample the same length at the input vector of choices\nThe third argument indicates that if a vector should be sampled with replacement (that is, can items be repeatedly sampled). The default is FALSE (meaning no).\nWe can also specify the probability of sampling any item in the input vector. If we don’t provide this information, then all item is assumed to have equal probabilities of being sampled.\nIt will return a vector of the item sampled\n\n\nx <- 1:100\nx\n\n  [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18\n [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36\n [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54\n [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72\n [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90\n [91]  91  92  93  94  95  96  97  98  99 100\n\nsample(x, 10, replace = TRUE)\n\n [1] 95 36 23 65 19 85 77 14  6 80\n\n\n\n\n\n\n\n\nNote\n\n\n\nIt is normal to struggle with R code. Newer users of R struggle more than seasoned users, but we all end up experiencing an apparently intractable problem, one that we cannot solve despite our best efforts. The first response may be to Google that problem (which may yield helpful information), but there are also more efficient search strategies you can employ to solve your R coding problem. Here is a blog post addressing that very topic: how to find help when we are stuck.\n\n\n\n\nBack to functions\nFunctions can return exactly one object (or none at all). If it does return an object, that can be assigned to a new object:\n\nnew <- function_name(value1, arg3 = value3)\n\nIf the output from a function is not assigned, it will be sent to the console instead (we’ve done this plenty during this workshop). Sometimes, this is fine! Maybe it is a small amount of output we are running to check data integrity. Or maybe it’s a giant data frame we deeply regret printing in the console.\n\n\nBase R and Contributed Libraries\nThis is the last section with a major focus on ‘base R’, that is the set of functions that come automatically loaded when you install and open R.\nTake a look at this long-ish cheat sheet (4 pages long!) of the many useful commands in base R. Skim through this and see if there is anything useful for you. It is meant to periodically skimmed, not studied in great detail (you’ll put yourself to sleep if you try to read it beginning to end).\nAdditionally, here is the ultimate guide to working with the R language. This is a long, highly technical document, but it is also incredibly detailed and informative. Reading this is like reading an encyclopedia - only read a a small section at a time. I do not recommend reading this beginning to end.\n\nLibraries\n\nBut also, the community keeps R humming and current by writing packages that extend R’s functionality. This is both awesome (the latest greatest tool is now enabled!) and bad (quality of implementation is not guaranteed and these packages are often not maintained over the long haul).\nThese packages are often made available on CRAN, the comprehensive R archive network, as well Bioconductor() or via GitHub, GitLab, independent websites. You can access those by first installing them, install.packages(\"package_name\") and then loading the package into an R session, library(package_name). Here’s an example using readr and *readxl**, packages we will use for data importation.\n\ninstall.packages(c(\"readr\", \"readxl\"))\n\nInstalling vroom [1.6.0] ...\n    OK [linked cache]\nInstalling readr [2.1.3] ...\n    OK [linked cache]\nInstalling readxl [1.4.1] ...\n    OK [linked cache]\n\nlibrary(readr)\nlibrary(readxl)\n\nNote that multiple packages can be listed in the install.packages() command, but not library(). Also, packages only need to be installed once, not repeatedly (unless a package needs to be a updated to the latest version). However, packages must be loaded in every R session or their functionality (including the help files) is not available.\n\n\n\n\n\n\nPutting it all together\n\n\n\nWhen you search for something in the Help pane, several types of help files will result: vignettes and function documentation. Function documentation is what we have just reviewed (detailed information on how to use a function). Vignettes are examples of how to use a collection of function in a package. They provide more context and a programmatic flow for using a package or accomplishing a particular goal. They are package tutorials. Vignettes are not included for function or even very package.\n\n\n\n\n\n\n\n\nLearning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\nUnderstand how to call functions using named and positional arguments\nBe able to access help files for an R function and know how to use the information provided in a help file"
  },
  {
    "objectID": "lessons/Lesson11.html",
    "href": "lessons/Lesson11.html",
    "title": "Special Lesson 11: Setting up R for Reproducible Research",
    "section": "",
    "text": "Install R & RStudio on your personal computer.\nCheck your installation and adjust RStudio settings\nUse projects!\nInstall packages\nDiscuss reproducible Research\n{{{ link to RR slides }}}\n\n\n\n\n\n\nPutting it all together\n\n\n\n\n\n\n::: {.callout-caution collapse=“true”} ## Learning Goals\nAt the end of this lesson, you should:\n\n::: s"
  },
  {
    "objectID": "lessons/Lesson07.html",
    "href": "lessons/Lesson07.html",
    "title": "Lesson 7: Importing Data into R",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\nknow how to set your working directory\nknow how to specify a file path\nBe able to import CSV and Excel files into R\nunderstand the main arguments for importing .xlsx, .xls and .csv files"
  },
  {
    "objectID": "lessons/Lesson07.html#working-directory-and-file-paths",
    "href": "lessons/Lesson07.html#working-directory-and-file-paths",
    "title": "Lesson 7: Importing Data into R",
    "section": "Working directory and file paths",
    "text": "Working directory and file paths\nWhile you can simulate data or load existing data sets associated with packages for your research, most of you will need to load pre-existing data sets from you computer, or a cloud server, some other external device.\nThe first thing you need to understand is the working directory and file paths.\nWhen an R session is initiated, it ascertains what the root working directory is based on the default settings for your R installation and any other"
  },
  {
    "objectID": "lessons/Lesson07.html#how-to-import",
    "href": "lessons/Lesson07.html#how-to-import",
    "title": "Lesson 7: Importing Data into R",
    "section": "How to Import",
    "text": "How to Import\nThere are several ways to import data into R.\n\nUse the “Import Dataset” tool in the Environment pane.\n\n\nknitr::include_graphics(here::here(\"images\", \"import_dataset_enviro.png\"))\n\n\n\n\n\nUse the Files pane in RStudio\n\n\nknitr::include_graphics(here::here(\"images\", \"import_dataset_file.png\"))\n\n\n\n\nBoth of them open a new window that looks like this:\n\nknitr::include_graphics(here::here(\"images\", \"import_dataset_window.png\"))\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWhile these point-and-click interfaces are very convenient, they don’t automatically leave a trail of breadcrumbs to help you repeat the process in the future. But, they do generate R code that we can capture and reuse. They are handy shortcuts that I have found especially helpful when trying to import file formats I work with rarely.\n\n\n\nManual command line import\n\nUltimately, this is how anything is imported into R. As mentioned, first two options listed above are actually tools for generating code that will import a data set through the command-line!\nThere’s 4 common approaches for importing data into R:\n\nread.csv()\nread_csv()\nread_excel()\nread_delim()\n\n\nread.csv()\nA very commonly used funtion for reading in “comma separated values” (CSV) files. I personally like this format because it is not proprietary and is compatable across many operating systems. It also limitts all sorts of extraneous formatting that itself is a barrier to reproducible research (e.g. highlighting is discarded once a CSV file is closed).\nExample usage:\n\nmycsv1 <- read.csv(\"data/trial_metadata.csv\")\n\n\n\n\nResult:\n\nstr(mycsv1)\n\n'data.frame':   28 obs. of  30 variables:\n $ trial             : chr  \"SWIdahoCereals_HWW_PAR_2020\" \"SWIdahoCereals_SWW_PAR_2020\" \"SWIdahoCereals_H_W_PAR_2018\" \"SWIdahoCereals_SWW_PAR_2018\" ...\n $ program           : chr  \"SWIdahoCereals\" \"SWIdahoCereals\" \"SWIdahoCereals\" \"SWIdahoCereals\" ...\n $ pi                : chr  \"OWalsh\" \"OWalsh\" \"OWalsh\" \"OWalsh\" ...\n $ nursery           : chr  \"HWW\" \"SWW\" \"H_W\" \"SWW\" ...\n $ year              : int  2020 2020 2018 2018 2018 2018 2016 2016 2016 2017 ...\n $ location          : chr  \"Parma\" \"Parma\" \"Parma\" \"Parma\" ...\n $ grower_cooperator : chr  \"UI Parma REE Center\" \"UI Parma REE Center\" \"UI Parma REE Center\" \"UI Parma REE Center\" ...\n $ irrigation        : chr  \"irrigated\" \"irrigated\" \"irrigated\" \"irrigated\" ...\n $ latitude          : num  43.8 43.8 43.8 43.8 43.8 ...\n $ longitude         : num  -117 -117 -117 -117 -117 ...\n $ planting_date     : chr  \"2019-10-07\" \"2019-10-07\" \"2017-10-25\" \"2017-10-25\" ...\n $ harvest_date      : chr  \"2020-07-21\" \"2020-07-21\" \"2018-07-17\" \"2018-07-17\" ...\n $ plot_length       : int  17 17 17 17 17 17 17 17 17 17 ...\n $ plot_width        : int  5 5 5 5 5 5 5 5 5 5 ...\n $ agronomic_notes   : logi  NA NA NA NA NA NA ...\n $ chemical_trts     : logi  NA NA NA NA NA NA ...\n $ free_lime_pct     : logi  NA NA NA NA NA NA ...\n $ k_ppm             : logi  NA NA NA NA NA NA ...\n $ n_lbs_acre        : logi  NA NA NA NA NA NA ...\n $ npks_lb_acre      : logi  NA NA NA NA NA NA ...\n $ p_ppm             : logi  NA NA NA NA NA NA ...\n $ ph                : logi  NA NA NA NA NA NA ...\n $ previous_crop     : logi  NA NA NA NA NA NA ...\n $ row_spacing_in    : logi  NA NA NA NA NA NA ...\n $ s_ppm             : logi  NA NA NA NA NA NA ...\n $ seed_rate_per_acre: logi  NA NA NA NA NA NA ...\n $ seed_trt          : logi  NA NA NA NA NA NA ...\n $ soil.type         : logi  NA NA NA NA NA NA ...\n $ soil_om           : logi  NA NA NA NA NA NA ...\n $ exp_design        : chr  \"RCBD\" \"RCBD\" \"RCBD\" \"RCBD\" ...\n\n\nDetails:\nread.csv() is actually a “wrapper” for another function, read.table(). It has taken read.table() and set the default arguments to work with CSV files. read.table() is a more generalized form providing more flexibility.\nThe default arguments include: * colnames = TRUE: the first row of data is assumed to be the column names * nothing in the data set will be used for rownames unless we explicitly indicate so * sep = \",\": each data point is separated from another by a comma * a newline indicator is used to separate rows of data * na.strings = c(\"NA\", \"\"): cells with a either no data (““) or an”NA” will be treated as missing. * if something consists of non-numeric characters, that column vector will be treated as character and not a factor\n\n\nread_csv()\nThis function is part of readr. It has very similar functionality to read.csv(), but it parses the data a wee bit different.\nExample Usage:\nFirst, load the package that contains the function read_csv()\n\nlibrary(readr)\n\n\nmycsv2 <- read_csv(\"data/trial_metadata.csv\", trim_ws = TRUE)\n\n\n\nRows: 28 Columns: 30\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr   (8): trial, program, pi, nursery, location, grower_cooperator, irrigat...\ndbl   (5): year, latitude, longitude, plot_length, plot_width\nlgl  (15): agronomic_notes, chemical_trts, free_lime_pct, k_ppm, n_lbs_acre,...\ndate  (2): planting_date, harvest_date\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nResult:\n\nstr(mycsv2)\n\nspc_tbl_ [28 × 30] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ trial             : chr [1:28] \"SWIdahoCereals_HWW_PAR_2020\" \"SWIdahoCereals_SWW_PAR_2020\" \"SWIdahoCereals_H_W_PAR_2018\" \"SWIdahoCereals_SWW_PAR_2018\" ...\n $ program           : chr [1:28] \"SWIdahoCereals\" \"SWIdahoCereals\" \"SWIdahoCereals\" \"SWIdahoCereals\" ...\n $ pi                : chr [1:28] \"OWalsh\" \"OWalsh\" \"OWalsh\" \"OWalsh\" ...\n $ nursery           : chr [1:28] \"HWW\" \"SWW\" \"H_W\" \"SWW\" ...\n $ year              : num [1:28] 2020 2020 2018 2018 2018 ...\n $ location          : chr [1:28] \"Parma\" \"Parma\" \"Parma\" \"Parma\" ...\n $ grower_cooperator : chr [1:28] \"UI Parma REE Center\" \"UI Parma REE Center\" \"UI Parma REE Center\" \"UI Parma REE Center\" ...\n $ irrigation        : chr [1:28] \"irrigated\" \"irrigated\" \"irrigated\" \"irrigated\" ...\n $ latitude          : num [1:28] 43.8 43.8 43.8 43.8 43.8 ...\n $ longitude         : num [1:28] -117 -117 -117 -117 -117 ...\n $ planting_date     : Date[1:28], format: \"2019-10-07\" \"2019-10-07\" ...\n $ harvest_date      : Date[1:28], format: \"2020-07-21\" \"2020-07-21\" ...\n $ plot_length       : num [1:28] 17 17 17 17 17 17 17 17 17 17 ...\n $ plot_width        : num [1:28] 5 5 5 5 5 5 5 5 5 5 ...\n $ agronomic_notes   : logi [1:28] NA NA NA NA NA NA ...\n $ chemical_trts     : logi [1:28] NA NA NA NA NA NA ...\n $ free_lime_pct     : logi [1:28] NA NA NA NA NA NA ...\n $ k_ppm             : logi [1:28] NA NA NA NA NA NA ...\n $ n_lbs_acre        : logi [1:28] NA NA NA NA NA NA ...\n $ npks_lb_acre      : logi [1:28] NA NA NA NA NA NA ...\n $ p_ppm             : logi [1:28] NA NA NA NA NA NA ...\n $ ph                : logi [1:28] NA NA NA NA NA NA ...\n $ previous_crop     : logi [1:28] NA NA NA NA NA NA ...\n $ row_spacing_in    : logi [1:28] NA NA NA NA NA NA ...\n $ s_ppm             : logi [1:28] NA NA NA NA NA NA ...\n $ seed_rate_per_acre: logi [1:28] NA NA NA NA NA NA ...\n $ seed_trt          : logi [1:28] NA NA NA NA NA NA ...\n $ soil type         : logi [1:28] NA NA NA NA NA NA ...\n $ soil_om           : logi [1:28] NA NA NA NA NA NA ...\n $ exp_design        : chr [1:28] \"RCBD\" \"RCBD\" \"RCBD\" \"RCBD\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   trial = col_character(),\n  ..   program = col_character(),\n  ..   pi = col_character(),\n  ..   nursery = col_character(),\n  ..   year = col_double(),\n  ..   location = col_character(),\n  ..   grower_cooperator = col_character(),\n  ..   irrigation = col_character(),\n  ..   latitude = col_double(),\n  ..   longitude = col_double(),\n  ..   planting_date = col_date(format = \"\"),\n  ..   harvest_date = col_date(format = \"\"),\n  ..   plot_length = col_double(),\n  ..   plot_width = col_double(),\n  ..   agronomic_notes = col_logical(),\n  ..   chemical_trts = col_logical(),\n  ..   free_lime_pct = col_logical(),\n  ..   k_ppm = col_logical(),\n  ..   n_lbs_acre = col_logical(),\n  ..   npks_lb_acre = col_logical(),\n  ..   p_ppm = col_logical(),\n  ..   ph = col_logical(),\n  ..   previous_crop = col_logical(),\n  ..   row_spacing_in = col_logical(),\n  ..   s_ppm = col_logical(),\n  ..   seed_rate_per_acre = col_logical(),\n  ..   seed_trt = col_logical(),\n  ..   `soil type` = col_logical(),\n  ..   soil_om = col_logical(),\n  ..   exp_design = col_character()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n\n\nDetails:\nThis function takes similar arguments to read.csv(), although the output is more extensive.\n\nLike in read.csv(), the default seperator is “,”, missing datea are coded as empty string \"\" or NA and the first line is assumed to be the column header\nit does not bother with a row names attribute\nthe argument trim_ws will remove leading and trailing whitespace for data entries. So the column header ” soil pH” will become “soil pH”.\nColumn are preserved more clearly than read.csv() (including spaces and special characters). I’m honestly not fond of this behavior and usually clean up weird column names with janitor::clean_names().\n\nThe output is largely similar, although read_csv() actually parses dates, unlike read.csv().\n\n\nread_excel()\nThis function will read in MS Excel files (reliably)! It is truly amazing. For many many years, it was cumbersome and/or impossible to read Excel files direclty into R.\nExample Usage:\nLoad the package that contains the function read_excel()\n\nlibrary(readxl)\n\n\nmyxl <- read_excel(\"data/field_trial_2009.xlsx\", sheet = \"site_02\")\n\n\n\n\nResults:\n\nstr(myxl)\n\ntibble [80 × 30] (S3: tbl_df/tbl/data.frame)\n $ plot    : num [1:80] 1 2 3 4 5 6 7 8 9 10 ...\n $ bloc    : num [1:80] 1 1 1 1 1 1 1 1 1 1 ...\n $ rep     : num [1:80] 1 1 1 1 1 1 1 1 1 1 ...\n $ Ptrt    : chr [1:80] \"high\" \"high\" \"high\" \"high\" ...\n $ inoc    : chr [1:80] \"myco\" \"myco\" \"myco\" \"myco\" ...\n $ Cv      : chr [1:80] \"OTIS\" \"ALPOWA\" \"BlancaG\" \"WALWORTH\" ...\n $ order   : num [1:80] 1 2 3 4 5 17 18 16 20 19 ...\n $ height  : num [1:80] 49 48.7 40.3 45.7 59 ...\n $ spikes  : num [1:80] NA 240 192 360 216 340 220 228 208 256 ...\n $ tstwt   : num [1:80] 61.9 61.2 61.3 60.6 61.7 60.2 61.2 61.2 62.1 62.1 ...\n $ HI      : num [1:80] 0.385 0.375 0.444 0.385 0.481 0.387 0.5 0.5 0.474 0.409 ...\n $ YieldKg : num [1:80] 1144 1274 1026 1026 922 ...\n $ YieldBu : num [1:80] 16.5 18.5 14.9 15.1 13.3 ...\n $ tkw     : num [1:80] 35.1 32.2 37.6 30.8 40.1 ...\n $ myco    : num [1:80] 37.5 30 35.7 15.4 14.3 ...\n $ PT1     : num [1:80] 4391 4500 4546 3436 4121 ...\n $ PT2     : num [1:80] 1040 726 605 702 1036 ...\n $ PT3     : num [1:80] 375 85.5 315.6 247.4 161.9 ...\n $ Pseeds  : num [1:80] 3182 2523 3156 3389 2473 ...\n $ cruc    : num [1:80] 6 10 4 5 2 3 9 7 39 66 ...\n $ Cu      : num [1:80] 6.11 4.72 5.99 5.69 4.48 ...\n $ Fe      : num [1:80] 46.4 27.2 46.8 36.5 34.2 ...\n $ Mn      : num [1:80] 28 21.5 28.2 28.4 23.8 ...\n $ Zn      : num [1:80] 16.2 14.2 18.3 22.1 15.1 ...\n $ Protein : num [1:80] 14.3 12.7 14.7 16.3 12 ...\n $ SDS     : num [1:80] 9.9 9.9 13.1 12.5 9.6 13.7 13.4 9.3 9.6 10.2 ...\n $ PT1_2   : num [1:80] 4371 4455 4442 3481 4146 ...\n $ PT2_2   : num [1:80] 968 659 544 635 965 ...\n $ PT3_2   : num [1:80] 387 104 328 262 179 ...\n $ Pseeds_2: num [1:80] 3103 2482 3083 3296 2434 ...\n\n\nDetails\n\nBy default, read_excel() will import the first sheet unless it named by position (e.g. 1, 2, 3) or name (like in the previous example).\nThe default argument for missing values is only an empty string \"\"\nIt returns results very similar to read_csv().\nThere is also an argument, range for setting a custom range of cells to read in.\n\n\n\nread_delim()\nFor reading in text files! It’s pretty simple. Text files are not used terribly frequently, but I see them now and then with really huge files, such as genotyping data.\n\n#mytxt <- read.delim(\"data/genotypic_data.txt\")\n\n\n\n\nResults\n\n#str(mytxt)\n\nDetails\nNot much to say here - it’s basically like read.csv()!\n\n\n\n\n\n\nNote\n\n\n\nIt’s useful to understand how R has read a data set into an R session. R has opened a connection to the file that you have specified, read file information into the R session using system memory (your computer’s RAM), and then closed the connection.\nThis is a one-way process from your file to R\nOnce a file is loaded and the connection closed, there is no longer any link between the object loaded into memory in R and its origin file (located on on your computer, a cloud server, etc). Any changes made to the object in R will not change the file on your computer unless you explicitly run scripts to overwrite that file. This is good thing; it gives you freedom to experiment with and manipulate an object without worrying about messing up the original file.\nWe will discuss later how to export R objects to your file system when you want to capture changes made to an object.\n\n\n\n\nTroubleshooting Import errors\nThings frequently go wrong when importing data. This can sometimes be corrected by changing the import arguments, but often it indicates problems with the incoming data.\nSome possible errors and how to fix them:\n\nSome variables which should be numeric are characters instead. At least one item contains an unexpected character that renders that observation - and the rest of the vector - as a character. This might be two decimal points, a comma, or a “O” instead of “0”. If possible, manually inspect the data and correct the error. \nMissing data are not coded as missing. Import functions have default values for what is interpreted as missing. Check the documentation and adjust the arguments as needed to capture what code a data sets is using to indicate missing data.\n\nThe best choice is to properly arrange your data set prior to import. Broman & Woo (2018) provides some straightforward recommendations on how to manage data in spreadsheets.\n\n\nImporting Other Data types\nThe instructions provided above are for importing tabular data that is generally not “big data”.\nBig data is a subjective term that is system-dependent (and is rapidly changing as PC computing power and memory increases). Some personal computers can easily handle a 50 Mb file, while others cannot. If you are waiting more than 5 seconds for your data to import, then consider other options. A deep discussion about how to handle large data sets are beyond the scope of this workshop, but at the very minimum, consider the package data.table and its high-performance functions for reading and writing data, fread() and fwrite(). If your data sets are too big to load directly into R, consider arrow.\nYou may also be working with data types that are not strictly tabular, at least in the form they are stored on a computer. Here are some common non-tabular data types and packages to handle import of those.\n\nspatial data: sf, sp, raster\nSAS data sets: haven, haven::read_sas()\nSPSS data sets: haven, haven::read_sav()\ntabular files on Google drive: googledrive\nimage files: magick\n\n…and so much more.\n\n\n\n\n\n\nPutting it all together"
  },
  {
    "objectID": "lessons/Lesson15.html",
    "href": "lessons/Lesson15.html",
    "title": "Lesson 15: Repeating Actions with Purrr",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\n\n\n\n\n\n\n\n\nPutting it all together"
  },
  {
    "objectID": "lessons/Lesson08.html",
    "href": "lessons/Lesson08.html",
    "title": "Lesson 8: Introduction to Data Wrangling",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\nbe able to select columns in R using select()\nbe able to filter a data set\nknow to create new variables using mutate()\nbe able to rename variables\nbe able to sort a data set\nbe able to aggregate data and perform actions on those aggregated data\n\n\n\n\n\nSelecting columns\n\n\nFiltering a data set\n\n\nCreating New Variables\n\n\nRenaming Variables\n\n\nSorting a data set\n\n\nAggregating & Summarizing Data\n\n\n\n\n\n\nPutting it all together"
  },
  {
    "objectID": "lessons/Lesson10.html",
    "href": "lessons/Lesson10.html",
    "title": "Lesson 10: Combining Data Sets",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\nunderstand the concept of a “key” for merging\nbe able to merge two data sets together"
  },
  {
    "objectID": "lessons/Lesson10.html#bind-rows",
    "href": "lessons/Lesson10.html#bind-rows",
    "title": "Lesson 10: Combining Data Sets",
    "section": "Bind rows",
    "text": "Bind rows\nData sets are assumed to have a single observation in each row, and each column is a variable describing each observation in some way.\nIf you have two data sets of different observations and the same columns, you can do a row bind to stack the data sets:\n\nnew1 <- bind_rows(x, y)\n\nThe column names are match and ordered according to the first data frame listed. The default behavior is to return all unique columns from both data sets and fill in with missing data as needed."
  },
  {
    "objectID": "lessons/Lesson10.html#joins",
    "href": "lessons/Lesson10.html#joins",
    "title": "Lesson 10: Combining Data Sets",
    "section": "Joins",
    "text": "Joins\nMerging two data sets when it goes beyond a row bind can take an effort.\nAll joins follow this syntax:\n\nxxx_join(left_dataset, right_dataset)\n\n“left” and “right” correspond to the left and right ….\n\nLeft join\nReturn a merged data set with all the observations\n\n\nRight join\n\n\nFull join\nAll observations are returned, regardless if matched.\n\n\ninner join\n\n\n\nOnly observations found in both data sets are kept."
  },
  {
    "objectID": "lessons/Lesson10.html#final-thoughts",
    "href": "lessons/Lesson10.html#final-thoughts",
    "title": "Lesson 10: Combining Data Sets",
    "section": "Final Thoughts",
    "text": "Final Thoughts\n\n\n\n\n\n\nPutting it all together"
  },
  {
    "objectID": "lessons/Lesson12.html",
    "href": "lessons/Lesson12.html",
    "title": "Lesson 12: Exporting Data",
    "section": "",
    "text": "Learning Goals\n\n\n\n\n\nAt the end of this lesson, you should:\n\nBe able to export data from R\n\n\n\n\nThis is a very short lesson because exporting data is quite similar to importing data.\nThis lesson is focused on exporting tabular data.\n\nwrite.csv()\n\n\nwrite.table()\n\n\nwrite.delim()\n\n\nsave()\nThis is special option to save objects in your environment to file. These can only be used by R, but are convenient if you plan to return to these object:\nSave one object:\n\nsave(object1)\nsave(object1, object2)\n\nSave multiple objects:\n\nsave(object1, file = \"mydata.RData\")\nsave(object1, object2, object3,...)\n\n\n\n\n\n\n\nPutting it all together"
  },
  {
    "objectID": "lessons/Lesson00.html",
    "href": "lessons/Lesson00.html",
    "title": "Preparing for this Class",
    "section": "",
    "text": "Welcome & salutations!\nI excited to teach this course. I have fully revamped this curriculum, doing my best to recreate “beginner’s mind”.\nWe have very limited time, so order to conserve class time and have us all ready for the first day of class, please read through this “Lesson Zero”, watch the video and follow the instructions below.\n\n<<< video coming soon! >>>\n\n\nJoin Posit Cloud\nYou will receive an invitation to join a our online classroom on Posit Cloud, where you will need to sign up for an account using your email, or you can connect it to a Gmail or GitHub account (any of these choices will work fine for the class). If do you not have a Gmail or GitHub account, use your normal email instead. If you are taking this for course credit, please use your official UI email.\n\n\nClass Structure\nFor all lessons, please follow along in your RStudio cloud session. In most instances, you will type and run the same code that I will demonstrate.\nI will record each day’s lessons and make it available through email and Canvas. Additionally, all code generated that day will be posted on this course website shortly after each class ends. It is important that you read through notes and watch the video if (1) you had to miss some or all of a class, or (2) there is material you do not understand.\nIt is very important that you use the time between class sessions to ensure you understand the material.\n\n\nClass Notes Structure\nAs mentioned, all code run will be captured in class notes that will be posted. While you can read those notes and not attend class, many find it helpful to attend a live course and receive live instruction and feedback from an expert. Additionally, those of you formally registered for BCB 502 are required to attend at least 60% of the classes per the syllabus in order to pass.\nAt the beginning of each lesson, this box will be included:\n\n\n\n\n\n\nLearning Goals\n\n\n\n\n\nThis will be a list of what each lesson intends to teach.\nIf you do not think you have met those learning goals, please review the notes, rewatch the videos and if the material is still unclear, contact me.\n\n\n\nAt the end of most lessons, this box will be included:\n\n\n\n\n\n\nPutting it all together\n\n\n\nTips designed to weave together information from multiple lessons.\n\n\n\n\nHow to Suceed in Learning R\n\nAt the end of each class, review the learning goals and decide if you met those goals. These are designed to be the bare minimum of knowledge to competently use R. Later workshop/course content builds on this knowledge.\n\nReview what we have covered between classes - refresh your knowledge.\nIf there are practice problems, do them.\nExperiment in the R console using what you learned. Really, nothing can go wrong.\nIf class material is not clear, re-run the code from class and reread the notes; watch the videos. If it’s still not clear, contact me.\nCome to me with specific questions! I’m here to help.\n\n\n\nYour very first R lesson!\n\nR is case-sensitive! (“data” is different from “Data” and “DATA”). This means when typing commands, exercise great care and attention to detail so your code works.\nThere is no “undo” button in R. Once a command is run, you can’t undo it! (this is not as bad as it sounds)"
  },
  {
    "objectID": "schedule.html",
    "href": "schedule.html",
    "title": "Course Schedule",
    "section": "",
    "text": "This schedule is best understood as a draft that will be adjusted as needed.\n\n\n\nDate\nTopics\n\n\n\n\nBefore January 17\nWatch Welcome Video\n\n\nJanuary 17\nLesson 1: RStudio\nLesson 2: math operators\nLesson 3: vectorization\n\n\nJanuary 19\nLesson 4: objects\nLesson 5: data structures\nLesson 6: R functions & help\n\n\nJanuary 24\nLesson 7: data import\nLesson 8: data wrangling\n\n\nJanuary 26\nLesson 9: reshaping data sets\n\n\nJanuary 31\nLesson 10: combining data sets\n\n\nFebruary 2\nLesson 11: Your R set-up\nLesson 12: exporting data\nLesson 13: basic plotting\n\n\nFebruary 7\nLesson 14: ggplotting\n\n\nFebruary 9\nLesson 15: repeating actions"
  },
  {
    "objectID": "extra/lesson_00_slides.html",
    "href": "extra/lesson_00_slides.html",
    "title": "Welcome to Introductory R",
    "section": "",
    "text": "background-image: images/tui_la.jpg\n\nPractice is key\n\n\nbackground-image: images/music.jpg"
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "Jan 17 - February 9\nTuesday/Thursdays\n2 - 4 pm Pacific time\nAll courses will be recorded and made available after class is over through email. All materials will be posted on the course website."
  },
  {
    "objectID": "syllabus.html#instructor",
    "href": "syllabus.html#instructor",
    "title": "Syllabus",
    "section": "Instructor",
    "text": "Instructor\nJulia Piaskowski | training website | GitHub | personal website |"
  },
  {
    "objectID": "syllabus.html#office-hoursdrop-in-zoom-hours",
    "href": "syllabus.html#office-hoursdrop-in-zoom-hours",
    "title": "Syllabus",
    "section": "Office Hours/Drop-In Zoom Hours",
    "text": "Office Hours/Drop-In Zoom Hours\nWednesday/Friday, 1-2 pm over Zoom. Email me if you have questions but are unavailable at that time."
  },
  {
    "objectID": "syllabus.html#course-outline",
    "href": "syllabus.html#course-outline",
    "title": "Syllabus",
    "section": "Course Outline",
    "text": "Course Outline\nThis is an introductory course for the R programming language, the graphical user interface RStudio and how R can be used to manage and analyse your data. At the end of this course, with diligent study and application, you will be able to:\n\nimport & export data\nunderstand data types and object types\nfilter, reshape, merge and manipulate your data\nmathematically transform data\nplot data\nnavigate R help files\n\n\nThis course will not address:\n\ngit, GitHub, or any version control\nusage of the terminal (e.g. bash)\nstatistical analysis"
  },
  {
    "objectID": "syllabus.html#prerequisites",
    "href": "syllabus.html#prerequisites",
    "title": "Syllabus",
    "section": "Prerequisites",
    "text": "Prerequisites\nThis course is intended for beginner R users. No previous experience in R or any other programming/statistical language is expected (although previous R users whose skills have lapsed are welcomed!)"
  },
  {
    "objectID": "syllabus.html#course-requirements",
    "href": "syllabus.html#course-requirements",
    "title": "Syllabus",
    "section": "Course Requirements",
    "text": "Course Requirements\n\nComputer with a stable internet connection\nA camera and microphone for Zoom"
  },
  {
    "objectID": "syllabus.html#grades-policy",
    "href": "syllabus.html#grades-policy",
    "title": "Syllabus",
    "section": "Grades Policy",
    "text": "Grades Policy\nThis is a pass/fail class that is largely participation driven. Your ‘grade’ will be a direct reflection of your attendance and participation during class. Attendance and participation of 5 classes, or 62.5% of the total instruction time, will constitute a passing grade. Participating means attending and following along with the coding demonstration on your own computer.\nSome of you have already communicated with me regarding time you will miss due to scheduling conflicts with other courses. Your time away will not count against your attendance record and final grade. Please be sure to watch the videos and read the notes for the class time you miss so you do not fall behind in the course content."
  },
  {
    "objectID": "syllabus.html#inclusivity-accessibility",
    "href": "syllabus.html#inclusivity-accessibility",
    "title": "Syllabus",
    "section": "Inclusivity & Accessibility",
    "text": "Inclusivity & Accessibility\nI have attempted to create a course/workshop, course website and learning resources that are accessible and inclusive as possible. I welcome feedback on how to improve on this. If you need additional accommodations, I am happy to help. For official accommodations, University of Idaho policy requires that you work with the Center for Disability and Access Resources."
  },
  {
    "objectID": "syllabus.html#cheating-and-plagiarism",
    "href": "syllabus.html#cheating-and-plagiarism",
    "title": "Syllabus",
    "section": "Cheating and Plagiarism",
    "text": "Cheating and Plagiarism\nThis is not likely to be an issue in this course given that we have no true assignments that are graded. For reference, you can read about the University of Idaho plagiarism policy here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introductory R for Scientists",
    "section": "",
    "text": "This workshop will take you from zero to hero over the course of 16 hours of instruction and practice. It will introduce the R programming language, the graphical user interface RStudio and how R can be used to manage and analyse your data. At the end of this workshop, you will be able to:\n\nimport & export data\nunderstand data types and object types\nfilter, reshape, merge and manipulate your data\nmathematically transform data\ndo repeat actions in R\nplot data\nnavigate R help files\n\n\nWho is This workshop for?\nThis workshop is intended for beginner R users. No previous experience in R or any other programming or statistical language is expected (although previous R users whose skills have lapsed are welcomed!)\n\n\nWhat this workshop will not cover\n\ngit, GitHub, or any version control\nusage of the terminal (e.g. bash)\nstatistical analysis\n\n\n\nRequirements\n\na computer with a reliable internet connection\nA camera and microphone for Zoom\nA Zoom account (the free version is sufficient)\n\n\n\nWhen\nJan 17 - February 9\nTuesday/Thursdays\n2 - 4 pm Pacific time\nAll sessions will take place over Zoom so students across different timezones can participate.\n\n\nInstructors:\nJulia Piaskowski | GitHub"
  }
]